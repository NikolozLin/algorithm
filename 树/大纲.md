# 树

## 基础概念

由n个有限节点组成的具有层次关系的集合
特点：

- 每个节点有零个或多个子节点
- 没有父节点的节点为“根节点”
- 每个节点有且只有一个父节点
- 除根节点外，每个直接点

## 基础算法

一、**二叉树**

1. 先、中、后序遍历，以及非递归版本。
2. 二叉树类型判断（树型dp）：
    1.判断是否 **搜索二叉树**（每个节点的左树的节点都比右树大）
        判断：中序遍历是升序就搜索二叉树
    2.判断是否 **完全二叉树**
        判断：
        - 层次遍历，如果发现某个子节点只有右子树，没有左子树，那么就不是完全二叉树
        - 当节点单独直有左子树，那么剩下的全部节点都是 叶子节点
    3.判断是否 **满二叉树**
        - 判断树深度d，并统计全部节点个数N，如果满足 N=2^d-1，则该树是蛮二叉树
    3.判断是否 **平衡二叉树**（左树、右树高度差不超过1）
        -递归判断深度
3.给与两个节点，查询最近公共祖先
    解：
        - 建立fatherMap<当前节点，父节点>
        - 遍历其中一个节点的父节点，建立 fatherSet
        - 遍历第二个节点，如果在fatherSet 出现，就是最近公共祖先。

4.寻找一个节点的后继节点（中序遍历中一个节点的下一个节点）
    解：（中序）
        - 遍历全部节点，建立father指针。
        - 如果一个节点有右树，后继是右树最左节点。
        - 如果一个节点无右树，向上找父节点，找到一个节点是其父节点的左孩子，那么该父节点就是后继节点。
        - 上两个条件都无法满足，则他是最后一个节点。

5.（先、中、后）序遍历序列化和反序列化

## 拓展

红黑树、AVL、SB树（Size balanced tree）。
上面这些树都是由于`搜索二叉树`+`左旋、右旋逻辑` +`各自平衡标准` 组成

### AVL

- 任意节点的左右子树高度差不超过1.

- 检查边界 LL、RR、LR、RL 需要进行旋转

### size balance tree

- 每棵子树的大小，不小于其兄弟的子树大小（每棵叔叔树的大小，不小于其任何侄子树的大小）
  - 上面这个规则下，一个节点的左右树(假设左小右大) 右树大小<= 左树大小*2+1

- LL: (T节点的左孩子L，L的左子树A > T节点的右孩子) T右旋， 然后检查 子节点发生变化的节点（这里 T、L）。
- RR: 与上相反
- LR: (T节点的左孩子L，L的右子树B > T节点的右孩子) L 左旋变LL，T右旋， 检查节点
— RL: 相反

### 红黑树

- 每个节点不是红就是黑
- 红黑树的叶节点（null的空节点、不是平时的叶节点），头节点 叶节点黑色
- 红点不相邻
- cur当前节点开始，到每天节点到其每个叶子的路径包含相同 个数的黑色节点

## 跳表

实现有序表的结构，节点可以多个向外指的指针。

1.
