# 树

## 基础概念

由n个有限节点组成的具有层次关系的集合
特点：

- 每个节点有零个或多个子节点
- 没有父节点的节点为“根节点”
- 每个节点有且只有一个父节点
- 除根节点外，每个直接点

## 基础算法

一、**二叉树**

1. 先、中、后序遍历，以及非递归版本。
2. 二叉树类型判断（树型dp）：
    1.判断是否 **搜索二叉树**（每个节点的左树的节点都比右树大）
        判断：中序遍历是升序就搜索二叉树
    2.判断是否 **完全二叉树**
        判断：
        - 层次遍历，如果发现某个子节点只有右子树，没有左子树，那么就不是完全二叉树
        - 当节点单独直有左子树，那么剩下的全部节点都是 叶子节点
    3.判断是否 **满二叉树**
        - 判断树深度d，并统计全部节点个数N，如果满足 N=2^d-1，则该树是蛮二叉树
    3.判断是否 **平衡二叉树**（左树、右树高度差不超过1）
        -递归判断深度
3.给与两个节点，查询最近公共祖先
    解：
        - 建立fatherMap<当前节点，父节点>
        - 遍历其中一个节点的父节点，建立 fatherSet
        - 遍历第二个节点，如果在fatherSet 出现，就是最近公共祖先。

4.寻找一个节点的后继节点（中序遍历中一个节点的下一个节点）
    解：（中序）
        - 遍历全部节点，建立father指针。
        - 如果一个节点有右树，后继是右树最左节点。
        - 如果一个节点无右树，向上找父节点，找到一个节点是其父节点的左孩子，那么该父节点就是后继节点。
        - 上两个条件都无法满足，则他是最后一个节点。

5.（先、中、后）序遍历序列化和反序列化
